# 2022.06.19

- [x]  오늘 하루 공부했던 것에 대해 `정리하기`
- [x]  중요한 것을 `잊지않기`

# 🚩 Today I Learned

---

## 📚 정리하기

- 모던 자바 인 액션 요약 정리

---

## 🏷 잊지않기

- 발행자가 구독자에게 메세지를 밀어넣는(push) 것을 `압력` 이라고 표현함
    - 반대로 구독자가 발행자의 메세지를 가져오는(pull) 것을 `역압력` 이라고 표현
- 역압력 구조의 리액티브 프로그래밍을 reactive pull-base 라고 함
- `Future<T>.get()` 와 `CompletableFuture<T>.join()` 은 비슷한 동작을 수행한다
    - 비동기 연산의 결과를 동기적으로 가져옴
    - 연산 결과를 가져오는 동안은 `블록` 상태이다
    - 호출자와 피호출자가 다른 스레드에 존재한다고 하더라도 블록된다!
    - 결과를 가져오는 도중 피호출자의 연산 과정에서 예외가 발생해도 호출자의 스레드에서는 알지 못한다
        - 이 때 호출자의 스레드는 무한 대기 상태에 빠질 수도 있으니 주의
        - 타임아웃을 설정하여 피호출자의 연산 종료 대기 시간에 제한을 걸거나, 피호출자가 호출자에게 예외 발생을 알리는 것으로 대응할 수 있다
- 스트림으로 `CompletableFuture<T>` 컬렉션을 만들어 이 값들을 얻어오려면 스트림은 두 개로 나뉘어야 할 것이다
    - 하나의 스트림에서 `List<CompletableFuture<T>>` 를 만들고 연산 결과를 얻어오게 된다면 결국은 동기적으로 처리되는 것과 마찬가지임
        - 결국은 한 개의 `CompletableFuture<T>` 를 만들고 결과를 얻어오는 것 까지가 한 번의 루프 사이클이기 때문!!!
    - `List<CompletableFuture<T>>` 를 먼저 만들고 이에 대한 값을 별도의 스트림에서 처리하게 된다면  `List<CompletableFuture<T>>` 는 일단 반환되기 때문에 결과를 얻어오는 데에만 시간이 소요됨
- 스레드 풀의 개수를 적절하게 조절할 수 있는 공식이 있다고 한다
- 리액티브 프로그래밍의 핵심 요소 네 가지
    - 반응성
        - 빠르고 일정하고 예상할 수 있는 반응 시간을 제공
    - 회복성
        - 장애가 발생하도 시스템은 반응할 수 있어야함
        - 구독자와 발행자는 별도로 분리 되어 있음
    - 탄력성
        - 리액티브 시스템에서는 부하가 발생하면 자동으로 관련 컴포넌트에 할당된 자원 수를 늘림
    - 메세지 주도
- 애플리케이션 수준의 리액티브
    - 비동기 애플리케이션 구현의 추상화 수준을 높일 수 있음
    - 저수준의 멀티 스레드 관련 처리를 직접 하지 않아도 된다는 장점이 있음
    - 개발자가 비지니스 요구사항을 처리하는데에 좀 더 집중할 수 있는 환경을 만들어줌