- [x]  오늘 하루 공부했던 것에 대해 `정리하기`
- [x]  중요한 것을 `잊지않기`

# 🚩 Today I Learned

---

## 📚 정리하기

- 오브젝트 요약 정리 및 예제 코드 작성

---

## 🏷 잊지않기

- 생성자의 파라미터를 통해 올바른 상태를 가진 객체 생성을 보장할 수 있음
- 의존성을 가진다는 것
    - 어떤 클래스가 다른 클래스에 접근할 수 있는 경로를 가짐
    - 해당 클래스의 메서드를 호출하는 경우
- 코드의 의존성과 런타임 의존성은 다를 수 있음
    - 코드 상에서는 특정 인터페이스에 의존하고 있을지는 몰라도, 실제 런타임에서는 해당 인터페이스를 구현하는 다른 클래스에게 의존함
    - 이 때 코드를 이해하기 어려워지게 된다는 트레이드 오프가 발생함
    - 설계가 유연해질수록 나타나는 의존성의 양면성임
- 그럼에도 설계가 유연해져야 하는 이유
    - 유연한 설계
        - 코드를 이해하기 어려워짐
        - 디버깅이 어려워짐
        - 그러나 코드를 재사용하기 쉬워짐
        - 특정 클래스의 변경이 다른 클래스에게 영향이 적게 가는 구조
            - 즉, 확장하기 쉬워지는 구조
    - 유연하지 않은 설계
        - 코드를 이해하기 쉬움
        - 디버깅이 쉬움
        - 재사용하기 어려워짐
        - 특정 클래스의 변경은 다른 클래스의 변경을 초래
            - 즉, 확장하기 어려워짐
- 메세지를 받은 객체가 실행하는 메서드가 런타임 시점에 바인딩 되는 것을 `지연 바인딩` 혹은 `동적 바인딩` 이라고 함
    - 반대로 컴파일 시점에 바인딩 되는 것을 `초기 바인딩` 혹은 `정적 바인딩` 이라고 함
- 객체의 상속은 단순하게 코드의 재사용을 위한 상속이 아닌, 객체간의 다형적인 협력을 위해 인터페이스를 공유하기 위하여 상속해야함
    - 이러한 상속을 `인터페이스 상속` 이라고 함
- 유연성이 필요한 곳에 추상화를 사용
- 일반적인 상속의 단점
    - 부모 클래스의 캡슐화가 깨짐
    - 설계가 유현하지 못함
        - 실행 시점에 객체의 종류를 변경하는 것이 불가능
- 무엇보다 객체지향에서 가장 중요한 것은 애플리케이션의 기능을 구현하기 위해 협력에 참여하는 객체들 사이의 상호작용임